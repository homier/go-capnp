// Code generated by capnpc-go. DO NOT EDIT.

package testnetwork

import (
	capnp "github.com/homier/go-capnp/v3"
	text "github.com/homier/go-capnp/v3/encoding/text"
	schemas "github.com/homier/go-capnp/v3/schemas"
)

type PeerAndNonce capnp.Struct

// PeerAndNonce_TypeID is the unique identifier for the type PeerAndNonce.
const PeerAndNonce_TypeID = 0x9fae1e732359c0b5

func NewPeerAndNonce(s *capnp.Segment) (PeerAndNonce, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return PeerAndNonce(st), err
}

func NewRootPeerAndNonce(s *capnp.Segment) (PeerAndNonce, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return PeerAndNonce(st), err
}

func ReadRootPeerAndNonce(msg *capnp.Message) (PeerAndNonce, error) {
	root, err := msg.Root()
	return PeerAndNonce(root.Struct()), err
}

func (s PeerAndNonce) String() string {
	str, _ := text.Marshal(0x9fae1e732359c0b5, capnp.Struct(s))
	return str
}

func (s PeerAndNonce) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (PeerAndNonce) DecodeFromPtr(p capnp.Ptr) PeerAndNonce {
	return PeerAndNonce(capnp.Struct{}.DecodeFromPtr(p))
}

func (s PeerAndNonce) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s PeerAndNonce) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s PeerAndNonce) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s PeerAndNonce) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s PeerAndNonce) PeerId() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s PeerAndNonce) SetPeerId(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s PeerAndNonce) Nonce() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s PeerAndNonce) SetNonce(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

// PeerAndNonce_List is a list of PeerAndNonce.
type PeerAndNonce_List = capnp.StructList[PeerAndNonce]

// NewPeerAndNonce creates a new list of PeerAndNonce.
func NewPeerAndNonce_List(s *capnp.Segment, sz int32) (PeerAndNonce_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[PeerAndNonce](l), err
}

// PeerAndNonce_Future is a wrapper for a PeerAndNonce promised by a client call.
type PeerAndNonce_Future struct{ *capnp.Future }

func (f PeerAndNonce_Future) Struct() (PeerAndNonce, error) {
	p, err := f.Future.Ptr()
	return PeerAndNonce(p.Struct()), err
}

const schema_bcea0965c2a55c5b = "x\xda\x12Ht`1\xe4\xdd\xcf\xc8\xc0\x14(\xc2\xca" +
	"\xf6\x7f\xeb\x81H\xe5b\xb9u\xf3\x19\x02\x85\x18\x99\xfe" +
	"G\xc7,=\x94\xca\xf9j\x0f\x03\x0b;\x03\x83\xe0\xd1" +
	"_\x82\x17A\xf4\xd9r\x06\xdd\xff%\xa9\xc5%y\xa9" +
	"%\xe5L\xf9E\xd9z\xc9\x89\x05y\x05V\x01\xa9\xa9" +
	"E\x8ey\xf6)~\xf9y\xc9\xa9\x01\x8c\x8c\x81\x1c\xcc" +
	",\x0c\x0c,\x8c\x0c\x0c\x82\x9aV\x0c\x0c\x81*\xcc\x8c" +
	"\x81\x06L\x8c\x82\x8c\x8c\"\x8c A]#\x06\x86@" +
	"\x0df\xc6@\x13&F\xfb\x82\xd4\xd4\"\xcf\x14FN" +
	"\x06&FN\x06F\xf9<\x90\x190\x1e \x00\x00\xff" +
	"\xff\xe1\"&\xa5"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_bcea0965c2a55c5b,
		Nodes: []uint64{
			0x9fae1e732359c0b5,
		},
		Compressed: true,
	})
}
